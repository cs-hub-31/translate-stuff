# 页面缓存—内存和文件之间的事情

上一次我们查看了内核是如何管理用户斤程的虚拟内存的，但是文件和 IO 我们并没有涉及到。这一篇文章将会覆盖文件和内存之间的关系以及对性能的影响，这种关系非常重要但经常令人迷惑。

对于文件，操作系统有两个重要的问题必须得到解决。一个是硬盘的速度真的非常慢，并且相比内存，磁盘寻址的方式也很特殊。另外一个是文件需要被载入在物理内存中，并被多个程序共享。如果你使用进程管理器查看 Windows 的进程，你会看到大约 15MB 的 DLLs 被载入到每个进程中。我的 Windows 机器目前运行了 100 个进程，如果没有这种共享机制，这些进程将会需要大约 15GB 的物理内存，而且还只是用于普通的 DDLs，这非常糟糕。同样，几乎所有的 Linux 程序都需要 `ld.so` 和 `lib.c`,加上其他的一些普通库。

幸运的是，这两个问题都可以一次性解决:页面缓存，内核在其中存储页面大小的文件块。为了说明页面缓存，我将会借助一个叫做 render 的 Linux 程序，其将打开 scene.dat 文件，一次性从中读取 512 字节的内容，然后将数据存放到堆上分配块。

`read` 被调用的时候，3 个 4KB 的页帧在页缓存中存储了 `scene.data` 的一部分数据。所有的常规文件 IO 都会通过页面缓存。在 Linux x86 平台上，对于内核来说，文件是否一连串 4KB 大小的块组成的。如果你从文件中读取了单个字节，那么整个 4KB 大小的文件快都会从硬盘中读取出来并放置到页面缓存上。这是有意义的，因为磁盘的连续读性能会比较好，而且程序程序通常会从文件区域中读取多个字节。页面缓存知道文件中每个4KB块的位置，比如上面描述的块可以描述为#0、#1等。Windows 的机制与 Linux 类似，只不过它的页大小是 256KB 。

不幸的是，内核必须将页面缓存的内容从内核空间复制到用户缓存区，这会占用 CPU 时间并损害 CPU 自身的缓存，而且还会浪费物理内存的空间。上面介绍的方法降低了磁盘延迟，但是没办法摆脱其他问题。文件映射就是用来解决这个问题。

当你使用文件映射时，内核会将你的程序中的虚拟页面直接映射到页面缓存上。这会带来显著的性能提升。Windows 和 Linux 都得到了大约 30% 的性能提升。根据你应用程序的性质，这可能会节省大量的物理内存。