# 页面缓存—内存和文件之间的事情

上一次我们查看了内核是如何管理用户斤程的虚拟内存的，但是文件和 IO 我们并没有涉及到。这一篇文章将会覆盖文件和内存之间的关系以及对性能的影响，这种关系非常重要但经常令人迷惑。

对于文件，操作系统有两个重要的问题必须得到解决。一个是硬盘的速度真的非常慢，并且相比内存，磁盘寻址的方式也很特殊。另外一个是文件需要被载入在物理内存中，并被多个程序共享。如果你使用进程管理器查看 Windows 的进程，你会看到大约 15MB 的 DLLs 被载入到每个进程中。我的 Windows 机器目前运行了 100 个进程，如果没有这种共享机制，这些进程将会需要大约 15GB 的物理内存，而且还只是用于普通的 DDLs，这非常糟糕。同样，几乎所有的 Linux 程序都需要 `ld.so` 和 `lib.c`,加上其他的一些普通库。

幸运的是，这两个问题都可以一次性解决:页面缓存，内核在其中存储页面大小的文件块。为了说明页面缓存，我将会借助一个叫做 render 的 Linux 程序，其将打开 scene.dat 文件，一次性从中读取 512 字节的内容，然后将数据存放到堆上分配块。

`read` 被调用的时候，3 个 4KB 的页帧在页缓存中存储了 `scene.data` 的一部分数据。所有的常规文件 IO 都会通过页面缓存。在 Linux x86 平台上，对于内核来说，文件是否一连串 4KB 大小的块组成的。如果你从文件中读取了单个字节，那么整个 4KB 大小的文件快都会从硬盘中读取出来并放置到页面缓存上。这是有意义的，因为磁盘的连续读性能会比较好，而且程序程序通常会从文件区域中读取多个字节。页面缓存知道文件中每个4KB块的位置，比如上面描述的块可以描述为#0、#1等。Windows 的机制与 Linux 类似，只不过它的页大小是 256KB 。

不幸的是，内核必须将页面缓存的内容从内核空间复制到用户缓存区，这会占用 CPU 时间并损害 CPU 自身的缓存，而且还会浪费物理内存的空间。上面介绍的方法降低了磁盘延迟，但是没办法摆脱其他问题。文件映射就是用来解决这个问题。

当你使用文件映射时，内核会将你的程序中的虚拟页面直接映射到页面缓存上。这会带来显著的性能提升。Windows 和 Linux 都得到了大约 30% 的性能提升。根据你应用程序的性质，这可能会节省大量的物理内存。

内存映射可以让你像访问字节一样在内存中访问文件，而且不需要在复杂度和可读性上做出妥协。你可以在类 Unix 系统中尝试使用 mmap，或者在Windows中使用  CreateFileMapping，抑或在高级语言中使用包装器。当你映射一个文件时，操作系统并不会将所有的内容都读取到内存上，而是通过页错误的方式根据需要载入。在获得具有所需文件内容的页帧后，故障处理程序会将虚拟页面映射到页面缓存。如果内容一开始没有缓存，这个过程将会涉及到磁盘 IO。

下面来个实际例子。假如我们的 `render` 程序退出后，页面缓存中的 `scene.dat` 数据是否会被立即释放？一种普遍的想法是会被立即释放掉，但实际上这个一个坏主意。实际上，程序退出后,文件被接下来的程序使用到的场景很常见，页面缓存必须覆盖到这个场景。进一步思考，为什么内核需要删除这个页缓存的内容呢？要知道，磁盘的速度比 RAM 慢 5 个数量级，因此如果能够命中页面缓存是一个巨大的胜利。因此，只要有足够的物理内存，缓存应该是满的。这样一来，缓存就不依赖于某一个特定的流程，而是整个系统范围内的资源。如果你运行 `render` 程序一周后缓存还存在于内存中，是一件非常有益的事。这就是为什么内核缓存的大小会逐步上升，直到达到限制。而是因为在某种程度上，释放物理内存是一种浪费，最好尽可能多地使用缓存。（译者注：尽可能得使用缓存这句话，应该在某个资源被多个进程共同需要的语境下才能说更适合，比如说服务器）

由于页面缓存的结构，当程序调用 `write()` 时，字节只是简单得复制到页面缓存而已，并且该页面会被标记为脏页面。一般来说磁盘 IO 并不会立即发生，所以你的程序不会被磁盘阻塞住。当然，缺点是当计算机突然奔溃时，你的数据可能没有持久化到磁盘上面。因此对于数据库的事务日志必须通过 `fsync()` 进行。对于读操作，一般会阻塞你的操作直到数据达到可用状态。内核采用提前加载的方式来缓解这个问题，在前面读取的例子中，内核会预先将一些页面加载到页面缓存中。你可以为内核提供文件顺序读取亦或者是随机读取的信息来帮助内核提前加载。在 Linux 中可以使用 `O_DIRECT` 绕过这种机制，一些数据库软件经常这么干。

一个文件的映射可能是私有的，也有可能是共享的。私有模式下内存中内容的更新不会提交到磁盘，或者对其他进程可见；而在共享模式下，更新是可见的。内核使用“写时复制”机制(通过页表条目启用)来实现私有映射。

只读页表条目并不意味着映射是只读的，它们只是内核的一个技巧，以达到尽可能共享物理内存的目的。这个设计的一些结果是，如何一些页面是只读的，那么其可以看到其他程序对文件做了哪些修改。一旦写时复制完成，其他程序的更改就不再可见。这种行为并没有得到内核的保证，而只是 x86 平台上的特性，从 API 的角度来看，这是有意义的。更新对其他进程来说是可见的，并出现在磁盘上。如何一个页面是只读的，页面错误将会触发段错误，而不是写时复制。

动态加载的库通过文件映射的方式被载入到你程序的地址空间中。他们没有什么神奇的地方，而是通过常规的 API 为你提供相同的私有文件映射。·