# mmap vs. 块读取

> origin stackoverflow site: https://stackoverflow.com/questions/45972/mmap-vs-reading-blocks

## 问题：

我正在编写一个可能会读取并处理大小为 100GB 甚至更大的文件，文件中包含了变量长度的集合。我已经实现了第一个版本，现在想优化下性能，尤其是在 IO 上，因为在读取文件的时候花费了太多时间。

使用 C++ 的 `fstream` 库在进行块读取的时候有没有什么经验法则吗？我想做的是读取一个大的块到缓冲里，然后从缓冲中读取完成的记录。

`mmap()` 可能会让代码变得非常混乱，因为 `mmap` 的块需要位于页面大小的边界内（我自己的理解），而我要处理的那些记录可能跨越页面的边界。使用 `fstream` 我可以定位到记录的开始然后开始重新读取，而不用局限于阅读页面大小边界内的块。

我如何在它们之间做出选中而不需要写出完整的实现代码？有什么经验法则（比如 `mmap()` 有 2 倍的性能优势）或者一些简单的测试吗？

## 回答

```text
@Dietrich Epp

我尝试着去寻找关于 `mmap/read` 在 Linux 上面的性能，在 Linux Kernel 的邮件列表里我发现一篇不错的帖子（[链接](http://marc.info/?l=linux-kernel&m=95496636207616&w=2)）。这片帖子是2000年的，所以在内核在 IO 和虚拟内存上会有很多改进。但它很完美得解释了为什么 `mmap` 或者 `read` 会更快/更慢。

- 一个 `mmap` 的调用的开销会比 `read` 大得多（就像 `epoll` 的开销会比 `poll` 大一样）。更改虚拟内存映射在某些处理器上是一项相当昂贵的操作，因为做上下文切换的成本非常高。
- IO 系统可能已经使用了磁盘缓存，所以如果你读了一个文件，你可能会命中缓存或者错过，不管你使用什么方法。

然而，

- 对于随机访问来说，内存映射通常会更快，尤其是你的访问模式无法预测的情况下。
- 内存映射允许你使用保持对内存页面的使用，直到你已经完成工作。这意味着如果你长时间使用一个大文件，然后关闭并重新打开它，该页面会一直保留在缓存里。如果使用`read`，你的文件可能会在就被缓存剔除了。这种方法不适用于你打开一个文件然后又立马丢弃它的场景（如果你试着使用`mclock`将页面保持在缓存里，那么你是在试图挑战磁盘缓存，这种愚蠢的做法对提高系统性能基本没有什么帮助）。
- 直接读一个文件非常简单并且非常快。

`mmap/read` 之间的讨论让我想起另外两个性能讨论：

- 一些 Java 程序员在发现非阻塞IO比阻塞IO还慢子后非常震惊。如果您知道非阻塞I/O需要进行更多的系统调用，那么这就不难理解了。
- 一些其他的网络程序员在知道 `epoll` 经常比 `poll` 性能差时也非常震惊，同样的理由，`epoll` 需要涉及到更多的 syscall。

总结：
内存映射适合数据随机访问、需要保持住一段时间、或者你知道你需要与其他进程共享数据这些场景。顺序访问数据或者读完马上丢弃这些场景，则应该直接读取文件。后者可以让你的代码不那么复杂。在没有实际测试和性能压测下，很难在现实世界中给出一个明确的答案，告诉你哪一种方式更快。
```

```text
@Tim Cooper

主要的性能开销在磁盘 IO 上。可以确定 `mmap()` 比 `istream` 快，但是这种差别不会特别明显，因为磁盘控制你的运行时间。

我曾试过 `Ben Collins`（该问题的其他回答） 的代码片段，以测试 `mmap()` 更快的断言，但是发现并没有明显的不同。

我绝对不会建议你将每条记录分别映射成mmap，这将是非常缓慢的，除非你的“记录”非常庞大。每条记录需要2次系统调用，而且可能会丢失磁盘缓存。

在你的场景中，我倒是觉得 `mmap()`, `istream` 和其他的底层读写接口基本类似。基于下面的理由，我会推荐使用 `mmap`:

1. 只有随机读。
2. 整个东西都可以在内存中，或者在文件中有引用位置。这些页面可以被映射到内存中，而其他页面被替换出来。这样的话操作系统可以最大限度得使用 RAM。
3. 如果多个进程正在读取/处理同一个文件，那么`mmap` 就非常适合，因为所有进程都共享相同的物理页面。

```