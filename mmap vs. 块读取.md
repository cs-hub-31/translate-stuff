# mmap vs. 块读取

> origin stackoverflow site: https://stackoverflow.com/questions/45972/mmap-vs-reading-blocks

## 问题：

我正在编写一个可能会读取并处理大小为 100GB 甚至更大的文件，文件中包含了变量长度的集合。我已经实现了第一个版本，现在想优化下性能，尤其是在 IO 上，因为在读取文件的时候花费了太多时间。

使用 C++ 的 `fstream` 库在进行块读取的时候有没有什么经验法则吗？我想做的是读取一个大的块到缓冲里，然后从缓冲中读取完成的记录。

`mmap()` 可能会让代码变得非常混乱，因为 `mmap` 的块需要位于页面大小的边界内（我自己的理解），而我要处理的那些记录可能跨越页面的边界。使用 `fstream` 我可以定位到记录的开始然后开始重新读取，而不用局限于阅读页面大小边界内的块。

我如何在它们之间做出选中而不需要写出完整的实现代码？有什么经验法则（比如 `mmap()` 有 2 倍的性能优势）或者一些简单的测试吗？

## 回答

我尝试着去寻找关于 `mmap/read` 在 Linux 上面的性能，在 Linux Kernel 的邮件列表里我发现一篇不错的帖子（[链接](http://marc.info/?l=linux-kernel&m=95496636207616&w=2)）。这片帖子是2000年的，所以在内核在 IO 和虚拟内存上会有很多改进。但它很完美得解释了为什么 `mmap` 或者 `read` 会更快/更慢。

- 一个 `mmap` 的调用的开销会比 `read` 大得多（就像 `epoll` 的开销会比 `poll` 大一样）。更改虚拟内存映射在某些处理器上是一项相当昂贵的操作，因为做上下文切换的成本非常高。
- IO 系统可能已经使用了磁盘缓存，所以如果你读了一个文件，你可能会命中缓存或者错过，不管你使用什么方法。

然而，

- 对于随机访问来说，内存映射通常会更快，尤其是你的访问模式无法预测的情况下。
- 内存映射允许你使用保持对内存页面的使用，直到你已经完成工作。这意味着如果你长时间使用一个大文件，然后关闭并重新打开它，该页面会一直保留在缓存里。如果使用`read`，你的文件可能会在就被缓存剔除了。这种方法不适用于你打开一个文件然后又立马丢弃它的场景（如果你试着使用`mclock`将页面保持在缓存里，那么你是在试图挑战磁盘缓存，这种愚蠢的做法对提高系统性能基本没有什么帮助）。
- 直接读一个文件非常简单并且非常快。